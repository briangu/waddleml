<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>waddle dashboard</title>
<style>
  :root { --bg:#0b1020; --fg:#e6eef8; --muted:#9ab; --accent:#65c3ff; --grid:#243049; }
  body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  header { padding:12px 16px; border-bottom:1px solid var(--grid); display:flex; gap:12px; align-items:center; }
  main { display:grid; grid-template-columns: 320px 1fr; min-height: calc(100vh - 54px); }
  aside { border-right:1px solid var(--grid); padding:12px; overflow:auto; }
  section { padding:12px; }
  .run { padding:6px 8px; border-radius:8px; margin:4px 0; cursor:pointer; background:#0f1730; border:1px solid #132040; }
  .run:hover { background:#122040; }
  .active { outline:2px solid var(--accent); }
  .row { display:flex; gap:8px; align-items:center; }
  .chip { font-size:12px; padding:2px 6px; border:1px solid var(--grid); border-radius:6px; color:var(--muted); }
  canvas { width:100%; height:360px; background:#0a1226; border-radius:12px; border:1px solid var(--grid); }
  select, button { background:#0f1730; color:var(--fg); border:1px solid var(--grid); border-radius:8px; padding:6px 8px; }
  .small { font-size:12px; color:var(--muted); }
</style>
</head>
<body>
<header>
  <strong>waddle</strong>
  <span class="small" id="wsStatus">ws: ⏸</span>
</header>
<main>
  <aside>
    <div class="row" style="justify-content:space-between">
      <span>Runs</span>
      <button onclick="loadRuns()">↻</button>
    </div>
    <div id="runs"></div>
  </aside>
  <section>
    <div class="row" style="gap:12px; margin-bottom:8px;">
      <label>Metric: <select id="metricKey"></select></label>
      <span class="chip" id="runInfo"></span>
    </div>
    <canvas id="chart"></canvas>
  </section>
</main>

<script>
const apiBase = location.origin;
let currentRun = null;
let allMetrics = [];   // [{key, step, ts, value}]
let keys = new Set();
let ws = null;

function fmtTime(ts){ const d=new Date((ts||0)*1000); return d.toISOString().replace('T',' ').slice(0,19); }

async function loadRuns() {
  const res = await fetch(apiBase + '/api/runs');
  const data = await res.json();
  const c = document.getElementById('runs'); c.innerHTML = '';
  data.forEach(r => {
    const div = document.createElement('div');
    div.className = 'run' + (currentRun && currentRun.id===r.id ? ' active' : '');
    div.onclick = () => { selectRun(r); };
    const start = new Date(r.started_at*1000).toLocaleString();
    div.innerHTML = `<div><strong>${r.name || '(no name)'}</strong></div>
                     <div class="small">${r.status} • ${start}</div>
                     <div class="small">${r.entry} @ ${r.commit_sha.slice(0,7)}</div>`;
    c.appendChild(div);
  });
}

async function selectRun(r) {
  currentRun = r;
  document.getElementById('runInfo').textContent = `${r.id.slice(0,6)} • ${r.status} • ${r.entry} • ${r.commit_sha.slice(0,7)}`;
  const res = await fetch(`${apiBase}/api/runs/${r.id}/metrics?limit=2000`);
  allMetrics = await res.json();
  keys = new Set(allMetrics.map(m => m.key));
  const sel = document.getElementById('metricKey');
  sel.innerHTML = '';
  [...keys].forEach(k => {
    const opt = document.createElement('option'); opt.value = k; opt.textContent = k; sel.appendChild(opt);
  });
  draw();
}

function connectWS() {
  try {
    ws = new WebSocket(`ws://${location.hostname}:${location.port * 1 + 1}`); // assume ws=port+1 if served together
    ws.onopen = () => document.getElementById('wsStatus').textContent = 'ws: ●';
    ws.onclose = () => document.getElementById('wsStatus').textContent = 'ws: ⏸';
    ws.onmessage = (e) => {
      try{
        const msg = JSON.parse(e.data);
        if (msg.type==='metric' && currentRun && msg.run_id===currentRun.id) {
          allMetrics.push({key: msg.key, step: msg.step, ts: msg.ts, value: msg.value});
          if (document.getElementById('metricKey').value === msg.key) draw(); // quick refresh
        }
      }catch(_){}
    };
  } catch(e) {}
}

function draw() {
  const selKey = document.getElementById('metricKey').value || [...keys][0];
  const data = allMetrics.filter(m => m.key===selKey).sort((a,b)=>a.step-b.step);
  const cv = document.getElementById('chart'); const ctx = cv.getContext('2d');
  const W = cv.width = cv.clientWidth * devicePixelRatio;
  const H = cv.height = cv.clientHeight * devicePixelRatio;
  // clear
  ctx.fillStyle = '#0a1226'; ctx.fillRect(0,0,W,H);
  // padding
  const L=60,R=20,T=10,B=40;
  // axes
  ctx.strokeStyle = '#243049'; ctx.lineWidth = 1;
  for (let i=0;i<=5;i++){ const y = T + (H-T-B)*i/5; ctx.beginPath(); ctx.moveTo(L,y); ctx.lineTo(W-R,y); ctx.stroke(); }
  for (let i=0;i<=10;i++){ const x = L + (W-L-R)*i/10; ctx.beginPath(); ctx.moveTo(x,T); ctx.lineTo(x,H-B); ctx.stroke(); }
  // scales
  const xs = data.length? data.map(d=>d.step): [0,1];
  const ys = data.length? data.map(d=>d.value): [0,1];
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const sx = (x)=> L + (W-L-R) * ((x-minX)/Math.max(1e-9,(maxX-minX||1)));
  const sy = (y)=> (H-B) - (H-T-B) * ((y-minY)/Math.max(1e-9,(maxY-minY||1)));
  // line
  ctx.strokeStyle = '#65c3ff'; ctx.lineWidth = 2; ctx.beginPath();
  data.forEach((d,i)=>{ const x=sx(d.step), y=sy(d.value); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
  ctx.stroke();
  // labels
  ctx.fillStyle = '#9ab'; ctx.font = `${12*devicePixelRatio}px system-ui`;
  ctx.fillText(selKey || '(no data)', L, T+16*devicePixelRatio);
  ctx.textAlign='right';
  ctx.fillText(`${minY.toFixed(4)} — ${maxY.toFixed(4)}`, W-R, T+16*devicePixelRatio);
}

document.getElementById('metricKey').onchange = draw;
loadRuns(); connectWS();
</script>
</body>
</html>